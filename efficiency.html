<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Developer Efficiency & Context Switching</title>
<style>
 body { font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:0; background:linear-gradient(135deg,#485563,#29323c); color:#1e2932; padding:18px; }
 .container { max-width:900px; margin:0 auto; background:#fff; border-radius:18px; padding:32px 34px 44px; box-shadow:0 18px 40px -12px rgba(0,0,0,.25); }
 h1 { margin:0 0 6px; font-weight:300; font-size:2.2rem; text-align:center; color:#1f2d3d; }
 .subtitle { text-align:center; color:#5f6b76; margin:0 0 26px; }
 nav a { color:#2962ff; text-decoration:none; font-weight:600; }
 nav { text-align:center; margin-bottom:24px; }
 .panel { background:#f6f8fa; border:1px solid #e2e8f0; padding:18px 20px 20px; border-radius:14px; margin-bottom:26px; }
 .panel h2 { margin:0 0 10px; font-size:1.15rem; font-weight:600; color:#253041; }
 label { font-size:.85rem; font-weight:600; display:block; margin-bottom:4px; letter-spacing:.5px; text-transform:uppercase; color:#475665; }
 input[type=range] { width:100%; }
 .grid { display:grid; gap:18px; grid-template-columns:repeat(auto-fit,minmax(190px,1fr)); margin-top:6px; }
 .metric { background:#fff; border:2px solid #e2e8f0; border-radius:12px; padding:14px 12px 16px; position:relative; }
 .metric h3 { margin:0 0 4px; font-size:.75rem; font-weight:600; letter-spacing:.6px; text-transform:uppercase; color:#5a6772; }
 .metric .value { font-size:1.9rem; font-weight:600; color:#0d47a1; line-height:1.15; }
 .metric small { display:block; font-size:.65rem; color:#607283; margin-top:2px; }
 .chart-wrap { margin-top:30px; background:#0d1117; padding:26px 22px 32px; border-radius:18px; box-shadow:0 10px 28px -8px rgba(0,0,0,.55); }
 canvas { width:100%; height:340px; display:block; background:#fff; border-radius:10px; box-shadow:0 0 0 1px #e2e8f0; }
.mode-toggle { display:flex; gap:10px; justify-content:center; margin-bottom:18px; flex-wrap:wrap; }
.mode-toggle button { background:#1e2932; color:#e2f1ff; border:1px solid #32414c; padding:8px 16px; border-radius:30px; cursor:pointer; font-size:.8rem; letter-spacing:.5px; font-weight:600; text-transform:uppercase; transition:.18s background,.18s color; }
.mode-toggle button.active { background:#2962ff; border-color:#2962ff; color:#fff; box-shadow:0 4px 14px -4px rgba(41,98,255,.55); }
.mode-toggle button:hover:not(.active){ background:#24323d; }
.week-note { text-align:center; font-size:.7rem; color:#93a2af; margin-top:10px; }
canvas#weekChart { height:760px; }
 .explain { font-size:.85rem; line-height:1.5; color:#334554; }
 .legend { display:flex; flex-wrap:wrap; gap:12px; margin-top:14px; }
 .legend span { display:inline-flex; align-items:center; gap:6px; font-size:.7rem; color:#d0d6dd; background:#1c242d; padding:6px 8px 6px 6px; border-radius:20px; }
 .legend i { width:14px; height:14px; border-radius:50%; display:inline-block; }
 .foot-note { margin-top:34px; font-size:.72rem; color:#637383; line-height:1.4; }
 .dual { display:flex; gap:26px; flex-wrap:wrap; }
 .dual > div { flex:1 1 260px; }
 .inline { display:flex; gap:12px; flex-wrap:wrap; }
 .inline .w50 { flex:1 1 120px; min-width:120px; }
 .slval { color:#0d47a1; background:#e3f2fd; padding:2px 6px; border-radius:10px; font-size:.65rem; margin-left:4px; }
 .chart-wrap { position:relative; }
 .cal-tip { position:absolute; pointer-events:none; background:rgba(20,24,28,.95); color:#e7eef5; font-size:.65rem; padding:6px 8px 6px; border-radius:6px; line-height:1.3; box-shadow:0 4px 14px -4px rgba(0,0,0,.5); transform:translate(-50%,-8px); z-index:10; opacity:0; transition:opacity .12s; white-space:nowrap; font-weight:500; border:1px solid #2d3944; }
 .cal-tip.visible { opacity:1; }
 .shuffle-btn { position:absolute; top:8px; right:8px; background:rgba(255,255,255,0.10); border:1px solid #32414c; color:#d2dde7; font-size:11px; padding:4px 8px; border-radius:14px; cursor:pointer; line-height:1; backdrop-filter:blur(4px); letter-spacing:.5px; }
 .shuffle-btn:hover { background:#2962ff; color:#fff; border-color:#2962ff; }
 .shuffle-btn:active { transform:translateY(1px); }
</style>
</head>
<body>
  <div class="container">
    <nav><a href="index.html">← Back to Network Complexity</a></nav>
    <h1>Developer Context Switching Efficiency</h1>
    <p class="subtitle">How meetings, project fragmentation, and interruptions erode effective output</p>

    <div class="panel">
      <h2>Interactive Factors</h2>
      <div class="dual">
        <div>
          <label for="projects">Concurrent Projects <span class="slval" id="val_projects">3</span></label>
          <input id="projects" type="range" min="1" max="8" value="3" />
        </div>
        <div>
          <label for="meetings">Meetings / Week <span class="slval" id="val_meetings">2</span></label>
          <input id="meetings" type="range" min="0" max="28" value="2" />
        </div>
        <div>
          <label for="interrupts">Unplanned Interruptions <span class="slval" id="val_interrupts">5</span></label>
          <input id="interrupts" type="range" min="0" max="16" value="5" />
        </div>
        <div>
          <label for="focusBlock">Longest Focus Block (hrs) <span class="slval" id="val_focusBlock">1.5h</span></label>
          <input id="focusBlock" type="range" min="0.75" max="3" step="0.25" value="1.5" />
        </div>
      </div>
      <div class="inline" style="margin-top:14px;">
        <div class="w50">
          <label for="taskSize">Avg Task Size (hrs) <span class="slval" id="val_taskSize">7.0h</span></label>
          <input id="taskSize" type="range" min="0.5" max="8" step="0.5" value="7" />
        </div>
        <div class="w50">
          <label for="recovery">Context Recovery (min) <span class="slval" id="val_recovery">8m</span></label>
          <input id="recovery" type="range" min="5" max="30" step="1" value="8" />
        </div>
  <!-- Fragmentation penalty removed (Option B simplification) -->
      </div>
    </div>

    <div class="grid" id="metrics">
      <div class="metric"><h3>Nominal Capacity</h3><div class="value" id="m_nominal">0h</div><small>Hours theoretically available (8h baseline)</small></div>
  <div class="metric"><h3>Focus Time</h3><div class="value" id="m_focus">0h</div><small>Estimated deep work hours (raw)</small></div>
  <div class="metric"><h3>Effective Output</h3><div class="value" id="m_effective">0h</div><small id="m_effectiveDetail">Focus × quality factor</small></div>
  <div class="metric"><h3>Utilization</h3><div class="value" id="m_util">0%</div><small>Effective / Nominal</small></div>
  <div class="metric"><h3>Switch Cost</h3><div class="value" id="m_switchCost">0h</div><small>Meetings + interruptions</small></div>
      <div class="metric"><h3>Context Index</h3><div class="value" id="m_contextIndex">0</div><small>Higher = more scattered (1–10)</small></div>
    </div>

    <div class="chart-wrap">
  <canvas id="weekChart" width="900" height="760" aria-label="Work week calendar"></canvas>
  <button id="reshuffleBtn" class="shuffle-btn" aria-label="Reshuffle schedule" title="Reshuffle random allocation">↻</button>
  <div id="calTooltip" class="cal-tip"></div>
      <div class="legend" id="legend">
    <span><i style="background:#1e88e5"></i> Focus Blocks</span>
  <span><i style="background:#8e24aa"></i> Meetings</span>
  <span><i style="background:#ef5350"></i> Interruptions</span>
  <span><i style="background:#90a4ae"></i> Quality Loss (shaded)</span>
  <span><i style="background:#ffa000"></i> Lunch</span>
  <span><i style="background:#ffd54f"></i> Socializing</span>
      </div>
      <div class="week-note" id="weekNote">Mon–Fri 08:00–16:00. Generated schedule is illustrative & heuristic.</div>
    </div>

    <p class="explain">This model is a simplified illustration. Increasing simultaneous projects raises cognitive load and reduces the average uninterrupted block size. Meetings and interruptions splinter the day, causing recovery overhead. Fragmentation penalty represents subtle productivity decay when tasks are forced into slices smaller than their natural size. Adjust sliders to see impact on effective output and switching losses.</p>

    <div class="foot-note">Assumptions: 8h gross day. Recovery applies after each meeting, interruption, and project shift. Focus block length bounded by longest focus slider and number of fragmentation events. This is not a scientific instrument — it's a conversation and intuition aid.</div>
  </div>
<script>
(function(){
  const els = id => document.getElementById(id);
  const inputs = ['projects','meetings','interrupts','focusBlock','taskSize','recovery'].map(els);
  const OUT = {
    nominal: els('m_nominal'), focus: els('m_focus'), effective: els('m_effective'), util: els('m_util'),
    switchCost: els('m_switchCost'), contextIndex: els('m_contextIndex')
  };
    const weekCanvas = els('weekChart');
  // Cached randomized weekly meeting distribution
  let meetingMapCache = null; // {0:[],1:[],2:[],3:[],4:[]}
  let prevMeetingCount = null;
  function generateMeetingMap(totalMeetings){
    const slots = [9.5,10,10.5,11,13,13.5,14,14.5]; // allowed start times
    const days = [0,1,2,3]; // Mon-Thu only
    const candidates = [];
    days.forEach(d=> slots.forEach(s=> candidates.push({day:d,start:s})));
    // Fisher-Yates shuffle for randomness
    for(let i=candidates.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [candidates[i],candidates[j]] = [candidates[j],candidates[i]];
    }
    const picked = candidates.slice(0, totalMeetings);
    const map = {0:[],1:[],2:[],3:[],4:[]};
    picked.forEach(p=> map[p.day].push(p.start));
    Object.values(map).forEach(arr=> arr.sort((a,b)=>a-b));
    return map;
  }

  const eventRects = []; // reused per render
  let lastInputSignature = '';
  let focusSeed = Math.floor(Math.random()*1e9);
  function calc(){
      const P = parseFloat(els('projects').value);
  const MWeekBase = parseFloat(els('meetings').value); // base weekly meetings from slider
      const totalMeetings = MWeekBase + P; // add one extra meeting per project
      const I = parseFloat(els('interrupts').value);
      const F = parseFloat(els('focusBlock').value);
      const TS = parseFloat(els('taskSize').value);
      const Rm = parseFloat(els('recovery').value);
      const signature = [P,MWeekBase,totalMeetings,I,F,TS,Rm].join('|');
      const grossDayHours = 8; // includes lunch
      const lunchDur = 0.5; // fixed lunch duration excluded from capacity
  const socialDur = 0.25; // 15 min post-lunch socializing
  const nominalHours = grossDayHours - lunchDur - socialDur; // remove lunch & socializing from productive capacity
  const meetingsPerDayAvg = totalMeetings / 5;
  const meetingTime = meetingsPerDayAvg * 0.5; // each meeting 0.5h, averaged per day
      const interruptActive = I * (5/60);
  // Regenerate random meeting map only when meeting count changes
  if(prevMeetingCount !== totalMeetings){
    meetingMapCache = generateMeetingMap(totalMeetings);
    prevMeetingCount = totalMeetings;
  }
  // Generate a new focus random seed only when inputs change (avoid flicker on multi-pass redraw)
  if(signature !== lastInputSignature){
    focusSeed = Math.floor(Math.random()*1e9);
    lastInputSignature = signature;
  }
  // Achievable focus (no explicit recovery subtraction in Option 3)
  const achievableFocusBlock = Math.min(F, TS);
  const focusTime = Math.max(0, nominalHours - meetingTime - interruptActive);
  const contextScatterIndex = Math.min(10, (P * 1.6) + (meetingsPerDayAvg*0.35) + (I*0.18));
  // Quality factor integrates switching severity (Rm) instead of explicit recovery blocks.
  const severityBoost = (Rm/30)*2.0; // adjusted for new 30 min max
  const combinedIndex = Math.min(12, contextScatterIndex + severityBoost);
  const qualityPenalty = Math.min(0.6, (combinedIndex/12)*0.6); // up to 60%
  const qualityFactor = 1 - qualityPenalty; // 1..0.4
  const effectiveOutput = focusTime * qualityFactor;
  const switchCost = meetingTime + interruptActive; // explicit time losses only
      OUT.nominal.textContent = nominalHours.toFixed(1)+ 'h';
    OUT.focus.textContent = focusTime.toFixed(1)+ 'h';
  OUT.effective.textContent = effectiveOutput.toFixed(1)+'h';
  OUT.util.textContent = Math.round((effectiveOutput/nominalHours)*100)+'%';
  OUT.switchCost.textContent = switchCost.toFixed(1)+'h';
  OUT.contextIndex.textContent = contextScatterIndex.toFixed(1);
  const loss = focusTime - effectiveOutput;
  const effDet = els('m_effectiveDetail');
  if(effDet) effDet.textContent = qualityFactor.toFixed(2)+'x (loss '+loss.toFixed(1)+'h)';
  // Update slider labels
  const setTxt = (id,val)=>{ const el=els(id); if(el) el.textContent=val; };
  setTxt('val_projects', P);
  setTxt('val_meetings', MWeekBase + ' (+'+P+'='+ totalMeetings +')');
  setTxt('val_interrupts', I);
  setTxt('val_focusBlock', F.toFixed(1)+'h');
  setTxt('val_taskSize', TS.toFixed(1)+'h');
  setTxt('val_recovery', Rm+'m');
  const metrics = {P,MWeekBase,totalMeetings,I,F,TS,focusTime,effectiveOutput,meetingTime,interruptActive,achievableFocusBlock, meetingsPerDayAvg, meetingMap: meetingMapCache, focusSeed};
      drawWeek(metrics);
      requestAnimationFrame(()=>drawWeek(metrics));
      setTimeout(()=>drawWeek(metrics),90);
      setTimeout(()=>drawWeek(metrics),240);
    }

  function drawWeek(data){
    eventRects.length = 0;
    const dpr = window.devicePixelRatio||1;
    // Fallback width if layout not resolved yet
  let logicalWidth = weekCanvas.clientWidth;
    if(!logicalWidth || logicalWidth < 50) {
      logicalWidth = weekCanvas.parentElement ? weekCanvas.parentElement.clientWidth : 900;
      if(!logicalWidth || logicalWidth < 50) logicalWidth = 900; // final fallback
    }
  const TOTAL_HEIGHT = 760;
  weekCanvas.width = logicalWidth * dpr;
  weekCanvas.height = TOTAL_HEIGHT * dpr;
    const ctxW = weekCanvas.getContext('2d');
    ctxW.setTransform(dpr,0,0,dpr,0,0);
  ctxW.clearRect(0,0,logicalWidth,TOTAL_HEIGHT);
  const margin = {top:30,left:60,right:30,bottom:30};
    const workHours = {start:8,end:16};
    const hourSpan = workHours.end - workHours.start; // 8
    const days = ['Mon','Tue','Wed','Thu','Fri'];
  const gridW = logicalWidth - margin.left - margin.right;
    const gridH = TOTAL_HEIGHT - (margin.top + margin.bottom); // dynamic drawing area height
    const colW = gridW / days.length;
    const hourToY = h => margin.top + ( (h - workHours.start) / hourSpan) * gridH;
    // Background & vertical day columns
    ctxW.font = '12px system-ui';
    days.forEach((d,i)=>{
      const x = margin.left + i*colW;
      ctxW.fillStyle = i%2? '#f5f7f9' : '#f1f5f9';
      ctxW.fillRect(x, margin.top, colW, gridH);
      ctxW.fillStyle = '#24323d';
      ctxW.font = '600 13px system-ui';
      ctxW.fillText(d, x + 8, margin.top - 8);
    });
    // Hour lines
    for(let h=workHours.start; h<=workHours.end; h++){
      const y = hourToY(h);
      ctxW.strokeStyle = '#d2d9e0';
      ctxW.lineWidth = (h%1===0)?1:0.5;
      ctxW.beginPath(); ctxW.moveTo(margin.left, y); ctxW.lineTo(margin.left+gridW, y); ctxW.stroke();
      ctxW.fillStyle = '#4a5965';
      ctxW.font = '11px system-ui';
      ctxW.fillText((h<10?'0':'')+Math.floor(h)+':00', 10, y+4);
    }
  // Build per-day schedule
  const meetingDur = 0.5; // hours
  const interruptDur = 5/60; // hours
  const MIN_FOCUS = 0.25; // 15 minutes minimum focus block length
  const MIN_INTERRUPT_GAP = 0.5; // require at least 30 minutes of focus between interruptions
  const usableFocus = data.focusTime; // per day (approx evenly assumed)
    const achievableBlock = data.achievableFocusBlock;
  const meetingSlots = [9.5,10,10.5,11,13,13.5,14,14.5];
  // Color palette: ensure meeting distinct from lunch (purple), lighter red for interruptions
  const palette = { focus:'#1e88e5', meeting:'#8e24aa', interrupt:'#ef5350', project:'#26a69a', lunch:'#ffa000', social:'#ffd54f', loss:'#90a4ae' };

    function makeRng(seed){
      let s = seed >>> 0;
      return function(){
        // xorshift32
        s ^= s << 13; s ^= s >>> 17; s ^= s << 5;
        return (s >>> 0) / 4294967296;
      };
    }
    function scheduleDay(dayIndex){
      let events = [];
  // Lunch and socializing block
  events.push({type:'lunch', start:11.5, end:12});
  events.push({type:'social', start:12, end:12.25});
      // Meetings distributed Mon-Thu only, none on Fri
      if(data.totalMeetings>0 && dayIndex < 4){
        const mtStartsDay = (data.meetingMap && data.meetingMap[dayIndex]) ? data.meetingMap[dayIndex] : [];
        mtStartsDay.forEach(start=> events.push({type:'meeting', start, end:start+meetingDur}));
      }
      events.sort((a,b)=>a.start-b.start);
      let remainingFocus = usableFocus;
      const rng = makeRng((data.focusSeed || 0) + dayIndex*1013904223 + 0x9e3779b9);
      const allocateGap = (gs,ge) => {
        let gapCursor = gs;
        while(remainingFocus > MIN_FOCUS && ge - gapCursor >= MIN_FOCUS){
          const gapRemaining = ge - gapCursor;
          const maxLen = Math.min(achievableBlock, remainingFocus, gapRemaining);
          if(maxLen < MIN_FOCUS) break;
          let minLen = MIN_FOCUS;
          let len = minLen + rng() * (maxLen - minLen);
          // Ensure leftover not a tiny fragment
            if(gapRemaining - len < MIN_FOCUS && gapRemaining - len > 0){
              len = gapRemaining; // extend to end
            }
          // Snap to nearest 5 minutes (optional for tidiness)
          const snap = 5/60;
          len = Math.round(len / snap) * snap;
          if(len < MIN_FOCUS) len = MIN_FOCUS;
          if(len > maxLen) len = maxLen;
          events.push({type:'focus', start:gapCursor, end:gapCursor+len});
          remainingFocus -= len;
          gapCursor += len;
        }
        if(gapCursor < ge){
          // fill remaining as synthetic focus (visual filler)
          const rem = ge - gapCursor;
          if(rem >= MIN_FOCUS) events.push({type:'focus', start:gapCursor, end:ge, synthetic:true});
        }
      };
      // Iterate gaps
      let cursor = workHours.start;
      for(const ev of events.slice()){
        if(ev.start > cursor) allocateGap(cursor, ev.start);
        cursor = Math.max(cursor, ev.end);
      }
      if(cursor < workHours.end) allocateGap(cursor, workHours.end);
      // Interruptions inserted into focus blocks
  let focusBlocks = events.filter(e=> e.type==='focus' && (e.end - e.start) > interruptDur*1.2);
      let lastInterruptEnd = -Infinity;
      for(let k=0; k<data.I && focusBlocks.length; k++){
        let attempts = 0;
        let placed = false;
        while(attempts < focusBlocks.length && !placed){
          const idx = ( (k+attempts)*37 + dayIndex*13 ) % focusBlocks.length;
          const fb = focusBlocks[idx];
          const mid = fb.start + (fb.end - fb.start) * (0.3 + 0.4*((k+dayIndex+attempts)%3)/2);
          let intStart = Math.max(fb.start, Math.min(fb.end - interruptDur, mid - interruptDur/2));
          // Ensure not back-to-back with previous interruption
          if(intStart < lastInterruptEnd + interruptDur*0.05){
            const shift = (lastInterruptEnd + interruptDur*0.05) - intStart;
            if(intStart + shift + interruptDur <= fb.end){
              intStart += shift;
            } else {
              attempts++; // try another block
              continue;
            }
          }
          // Enforce a larger focus gap between interruptions
          if(lastInterruptEnd > -Infinity){
            const sinceLast = intStart - lastInterruptEnd;
            if(sinceLast < MIN_INTERRUPT_GAP){
              // Try shifting forward inside the block if space allows
              const needed = MIN_INTERRUPT_GAP - sinceLast;
              if(intStart + needed + interruptDur <= fb.end){
                intStart += needed;
              } else {
                attempts++; // pick another block
                continue;
              }
            }
          }
          const intEnd = intStart + interruptDur;
          events = events.filter(e=> e!==fb);
          if(intStart - fb.start >= MIN_FOCUS) events.push({type:'focus', start:fb.start, end:intStart});
          events.push({type:'interrupt', start:intStart, end:intEnd});
          if(fb.end - intEnd >= MIN_FOCUS) events.push({type:'focus', start:intEnd, end:fb.end});
          lastInterruptEnd = intEnd;
          placed = true;
          focusBlocks = events.filter(e=> e.type==='focus' && (e.end - e.start) > interruptDur*1.2);
        }
      }
      // Clip & sort
      events = events.filter(e=> e.start < workHours.end && e.end > workHours.start);
      events.forEach(e=> { e.start = Math.max(e.start, workHours.start); e.end = Math.min(e.end, workHours.end); });
      events.sort((a,b)=> a.start - b.start || a.type.localeCompare(b.type));
      // Tighten small gaps between interruptions and meetings/lunch/social to avoid tiny visual focus slivers
      for(let i=0;i<events.length-1;i++){
        const a = events[i];
        const b = events[i+1];
        const gap = b.start - a.end;
        if(gap > 0 && gap < MIN_FOCUS){
          // Case: meeting then interruption -> pull interruption earlier
          if(a.type==='meeting' && b.type==='interrupt'){
            // shift interruption earlier by gap if it doesn't overlap with previous event
            const prev = events[i-1];
            if(!prev || (a.start - prev.end) >= 0){
              b.start -= gap; b.end -= gap;
            }
          } else if(a.type==='interrupt' && b.type==='meeting'){
            // push interruption forward so it ends exactly at meeting start
            const prev = events[i-1];
            const shift = gap;
            if(!prev || (a.start + shift) >= prev.end){
              a.start += shift; a.end += shift;
            }
          } else if(a.type==='interrupt' && (b.type==='lunch' || b.type==='social')){
            // push interruption forward to abut lunch/social
            const prev = events[i-1];
            const shift = gap;
            if(!prev || (a.start + shift) >= prev.end){
              a.start += shift; a.end += shift;
            }
          } else if((a.type==='lunch' || a.type==='social') && b.type==='interrupt'){
            // pull interruption earlier to abut lunch/social end
            const prev = events[i-1];
            if(!prev || prev.end <= a.end){
              b.start -= gap; b.end -= gap;
            }
          }
        }
      }
      // Fill any remaining gaps with synthetic focus (allow tiny fillers to avoid visual holes)
      const filled = [];
      let cur = workHours.start;
      for(const ev of events){
        if(ev.start > cur){
          const gapLen = ev.start - cur;
          if(filled.length && filled[filled.length-1].type==='focus'){
            // extend previous focus to cover gap
            filled[filled.length-1].end = ev.start;
          } else {
            filled.push({type:'focus', start:cur, end:ev.start, synthetic:true, tiny: gapLen < MIN_FOCUS});
          }
        }
        filled.push(ev);
        cur = Math.max(cur, ev.end);
      }
      if(workHours.end - cur > 0){
        if(filled.length && filled[filled.length-1].type==='focus') filled[filled.length-1].end = workHours.end;
        else filled.push({type:'focus', start:cur, end:workHours.end, synthetic:true});
      }

      // Normalize: merge adjacent focus & remove any residual short fragments < MIN_FOCUS
      filled.sort((a,b)=> a.start - b.start || a.type.localeCompare(b.type));
      const merged = [];
      for(const ev of filled){
        if(ev.type==='focus' && merged.length){
          const prev = merged[merged.length-1];
          if(prev.type==='focus' && Math.abs(prev.end - ev.start) < 1e-6){
            prev.end = Math.max(prev.end, ev.end);
            continue;
          }
        }
        merged.push(ev);
      }
  // Filter / adjust tiny focus blocks (after merging, any remaining sub-min blocks will be merged or kept as part of synthetic filler)
      for(let i=0;i<merged.length;i++){
        const ev = merged[i];
        if(ev.type==='focus' && (ev.end - ev.start) < MIN_FOCUS){
          const prev = merged[i-1];
          const next = merged[i+1];
          if(prev && prev.type==='focus' && Math.abs(prev.end - ev.start) < 1e-6){
            prev.end = ev.end; merged.splice(i,1); i--; continue;
          } else if(next && next.type==='focus' && Math.abs(ev.end - next.start) < 1e-6){
            next.start = ev.start; merged.splice(i,1); i--; continue;
          } else {
            // Cannot merge; drop it (leave small visual gap)
            merged.splice(i,1); i--; continue;
          }
        }
      }
      // Ensure day does not end on an interruption: convert/merge trailing interruption to focus
      if(merged.length){
        const last = merged[merged.length-1];
        if(last.type==='interrupt'){
          last.type='focus';
          const prev = merged[merged.length-2];
          if(prev && prev.type==='focus' && Math.abs(prev.end - last.start) < 1e-6){
            prev.end = last.end;
            merged.pop();
          }
        }
      }
      // Ensure day does not start with an interruption: convert/merge leading interruption to focus
      if(merged.length){
        const first = merged[0];
        if(first.type==='interrupt'){
          first.type='focus';
          const next = merged[1];
            if(next && next.type==='focus' && Math.abs(first.end - next.start) < 1e-6){
              next.start = first.start;
              merged.shift();
            }
        }
      }
      // Guarantee full-day coverage with focus at start and end (no visible gaps)
      if(merged.length){
        if(merged[0].start > workHours.start){
          if(merged[0].type==='focus') merged[0].start = workHours.start;
          else merged.unshift({type:'focus', start:workHours.start, end:merged[0].start, synthetic:true});
        }
        if(merged[merged.length-1].end < workHours.end){
          const last = merged[merged.length-1];
            if(last.type==='focus') last.end = workHours.end;
            else merged.push({type:'focus', start:last.end, end:workHours.end, synthetic:true});
        }
        // Merge any newly adjacent focus blocks
        for(let i=1;i<merged.length;i++){
          const prev = merged[i-1];
          const cur = merged[i];
          if(prev.type==='focus' && cur.type==='focus' && Math.abs(prev.end - cur.start) < 1e-6){
            prev.end = cur.end; merged.splice(i,1); i--; continue;
          }
        }
      }
      return merged;
    }
  // Draw events with effective overlay
    days.forEach((d,di)=>{
      const dayEvents = scheduleDay(di);
      const baseX = margin.left + di*colW;
      dayEvents.forEach(ev=>{
        const x = baseX + 4;
        const y = hourToY(ev.start) + 1;
        const w = colW - 8;
        const dur = ev.end - ev.start;
        const h = Math.max(4, (dur)/hourSpan * gridH - 2);
    eventRects.push({x,y,w,h,type:ev.type,start:ev.start,end:ev.end});
  ctxW.fillStyle = palette[ev.type] || '#90a4ae';
        ctxW.globalAlpha = ev.type==='focus'? 0.90 : 0.85;
        ctxW.beginPath();
        ctxW.roundRect ? ctxW.roundRect(x,y,w,h,6) : ctxW.fillRect(x,y,w,h);
        ctxW.fill();
        ctxW.globalAlpha = 1;
        if(ev.type==='focus'){
          const lostRatio = (data.focusTime>0)? Math.max(0,(data.focusTime - data.effectiveOutput)/data.focusTime):0;
          if(lostRatio>0){
            const lostH = Math.max(2, h * lostRatio);
            ctxW.fillStyle = palette.loss;
            ctxW.globalAlpha = 0.55;
            ctxW.beginPath();
            ctxW.roundRect ? ctxW.roundRect(x+1,y+1,w-2,lostH,4) : ctxW.fillRect(x+1,y+1,w-2,lostH);
            ctxW.fill();
            ctxW.globalAlpha = 1;
          }
        }
        ctxW.fillStyle = '#ffffff';
        ctxW.font = '600 10px system-ui';
        const label = ev.type==='focus'? 'Focus' : ev.type==='meeting'? 'Meet' : ev.type==='interrupt'? 'Int' : ev.type==='recovery'? 'Rec' : ev.type;
        if(h > 14) ctxW.fillText(label, x+6, y+12);
      });
    });
    // Title
    ctxW.fillStyle = '#1e2932';
    ctxW.font = '600 14px system-ui';
    ctxW.fillText('Weekly Calendar (Simulated)', margin.left, 18);
    if(!weekCanvas.dataset.initialized){
      weekCanvas.dataset.initialized = '1';
    }
  }

  // Hover tooltip
  const tip = document.getElementById('calTooltip');
  function fmtTime(t){
    const hh = Math.floor(t);
    const mm = Math.round((t - hh)*60);
    return (hh<10?'0':'')+hh+':'+(mm<10?'0':'')+mm;
  }
  weekCanvas.addEventListener('mousemove', e=>{
    const rect = weekCanvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio||1;
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const hit = eventRects.find(r=> x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h);
    if(hit){
  const labelMap = {focus:'Focus', meeting:'Meeting', interrupt:'Interruption', lunch:'Lunch', social:'Socializing'};
      tip.innerHTML = labelMap[hit.type]||hit.type;
      tip.innerHTML += '<br>'+fmtTime(hit.start)+'–'+fmtTime(hit.end);
      tip.style.left = x+'px';
      tip.style.top = y+'px';
      tip.classList.add('visible');
    } else {
      tip.classList.remove('visible');
    }
  });
  weekCanvas.addEventListener('mouseleave',()=> tip.classList.remove('visible'));

  const reshuffleBtn = document.getElementById('reshuffleBtn');
  if(reshuffleBtn){
    reshuffleBtn.addEventListener('click', ()=>{
      // Force new seeds & meeting redistribution
      const P = parseFloat(els('projects').value);
      const baseM = parseFloat(els('meetings').value);
      const totalM = baseM + P;
      meetingMapCache = generateMeetingMap(totalM);
      prevMeetingCount = totalM;
      focusSeed = Math.floor(Math.random()*1e9);
      lastInputSignature = '';
      calc();
    });
  }
  inputs.forEach(i=> i.addEventListener('input', calc));
  window.addEventListener('resize', calc);
  calc();
})();
</script>
</body>
</html>
