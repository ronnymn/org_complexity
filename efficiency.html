<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Developer Efficiency & Context Switching</title>
<style>
 body { font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:0; background:linear-gradient(135deg,#485563,#29323c); color:#1e2932; padding:18px; }
 .container { max-width:900px; margin:0 auto; background:#fff; border-radius:18px; padding:32px 34px 44px; box-shadow:0 18px 40px -12px rgba(0,0,0,.25); }
 h1 { margin:0 0 6px; font-weight:300; font-size:2.2rem; text-align:center; color:#1f2d3d; }
 .subtitle { text-align:center; color:#5f6b76; margin:0 0 26px; }
 nav a { color:#2962ff; text-decoration:none; font-weight:600; }
 nav { text-align:center; margin-bottom:24px; }
 .panel { background:#f6f8fa; border:1px solid #e2e8f0; padding:18px 20px 20px; border-radius:14px; margin-bottom:26px; }
 .panel h2 { margin:0 0 10px; font-size:1.15rem; font-weight:600; color:#253041; }
 label { font-size:.85rem; font-weight:600; display:block; margin-bottom:4px; letter-spacing:.5px; text-transform:uppercase; color:#475665; }
 input[type=range] { width:100%; }
 .grid { display:grid; gap:18px; grid-template-columns:repeat(auto-fit,minmax(190px,1fr)); margin-top:6px; }
 .metric { background:#fff; border:2px solid #e2e8f0; border-radius:12px; padding:14px 12px 16px; position:relative; }
 .metric h3 { margin:0 0 4px; font-size:.75rem; font-weight:600; letter-spacing:.6px; text-transform:uppercase; color:#5a6772; }
 .metric .value { font-size:1.9rem; font-weight:600; color:#0d47a1; line-height:1.15; }
 .metric small { display:block; font-size:.65rem; color:#607283; margin-top:2px; }
 .chart-wrap { margin-top:30px; background:#0d1117; padding:26px 22px 32px; border-radius:18px; box-shadow:0 10px 28px -8px rgba(0,0,0,.55); }
 canvas { width:100%; height:340px; display:block; background:#fff; border-radius:10px; box-shadow:0 0 0 1px #e2e8f0; }
.mode-toggle { display:flex; gap:10px; justify-content:center; margin-bottom:18px; flex-wrap:wrap; }
.mode-toggle button { background:#1e2932; color:#e2f1ff; border:1px solid #32414c; padding:8px 16px; border-radius:30px; cursor:pointer; font-size:.8rem; letter-spacing:.5px; font-weight:600; text-transform:uppercase; transition:.18s background,.18s color; }
.mode-toggle button.active { background:#2962ff; border-color:#2962ff; color:#fff; box-shadow:0 4px 14px -4px rgba(41,98,255,.55); }
.mode-toggle button:hover:not(.active){ background:#24323d; }
.week-note { text-align:center; font-size:.7rem; color:#93a2af; margin-top:10px; }
canvas#weekChart { height:520px; }
 .explain { font-size:.85rem; line-height:1.5; color:#334554; }
 .legend { display:flex; flex-wrap:wrap; gap:12px; margin-top:14px; }
 .legend span { display:inline-flex; align-items:center; gap:6px; font-size:.7rem; color:#d0d6dd; background:#1c242d; padding:6px 8px 6px 6px; border-radius:20px; }
 .legend i { width:14px; height:14px; border-radius:50%; display:inline-block; }
 .foot-note { margin-top:34px; font-size:.72rem; color:#637383; line-height:1.4; }
 .dual { display:flex; gap:26px; flex-wrap:wrap; }
 .dual > div { flex:1 1 260px; }
 .inline { display:flex; gap:12px; flex-wrap:wrap; }
 .inline .w50 { flex:1 1 120px; min-width:120px; }
 .slval { color:#0d47a1; background:#e3f2fd; padding:2px 6px; border-radius:10px; font-size:.65rem; margin-left:4px; }
</style>
</head>
<body>
  <div class="container">
    <nav><a href="index.html">← Back to Network Complexity</a></nav>
    <h1>Developer Context Switching Efficiency</h1>
    <p class="subtitle">How meetings, project fragmentation, and interruptions erode effective output</p>

    <div class="panel">
      <h2>Interactive Factors</h2>
      <div class="dual">
        <div>
          <label for="projects">Concurrent Projects <span class="slval" id="val_projects">3</span></label>
          <input id="projects" type="range" min="1" max="8" value="3" />
        </div>
        <div>
          <label for="meetings">Meetings / Day <span class="slval" id="val_meetings">2</span></label>
          <input id="meetings" type="range" min="0" max="12" value="2" />
        </div>
        <div>
          <label for="interrupts">Unplanned Interruptions <span class="slval" id="val_interrupts">5</span></label>
          <input id="interrupts" type="range" min="0" max="16" value="5" />
        </div>
        <div>
          <label for="focusBlock">Longest Focus Block (hrs) <span class="slval" id="val_focusBlock">2.0h</span></label>
          <input id="focusBlock" type="range" min="0.5" max="4" step="0.5" value="2" />
        </div>
      </div>
      <div class="inline" style="margin-top:14px;">
        <div class="w50">
          <label for="taskSize">Avg Task Size (hrs) <span class="slval" id="val_taskSize">2.0h</span></label>
          <input id="taskSize" type="range" min="0.5" max="8" step="0.5" value="2" />
        </div>
        <div class="w50">
          <label for="recovery">Context Recovery (min) <span class="slval" id="val_recovery">12m</span></label>
          <input id="recovery" type="range" min="2" max="45" step="1" value="12" />
        </div>
        <div class="w50">
          <label for="fragmentPenalty">Fragmentation Penalty % <span class="slval" id="val_fragmentPenalty">18%</span></label>
          <input id="fragmentPenalty" type="range" min="0" max="40" step="1" value="18" />
        </div>
      </div>
    </div>

    <div class="grid" id="metrics">
      <div class="metric"><h3>Nominal Capacity</h3><div class="value" id="m_nominal">0h</div><small>Hours theoretically available (8h baseline)</small></div>
      <div class="metric"><h3>Focus Time</h3><div class="value" id="m_focus">0h</div><small>Estimated deep work hours</small></div>
      <div class="metric"><h3>Effective Output</h3><div class="value" id="m_effective">0h</div><small>Focus time after switching drag</small></div>
      <div class="metric"><h3>Utilization</h3><div class="value" id="m_util">0%</div><small>Effective / Nominal</small></div>
      <div class="metric"><h3>Switch Cost</h3><div class="value" id="m_switchCost">0h</div><small>Time lost to project/meeting/task switching</small></div>
      <div class="metric"><h3>Fragment Loss</h3><div class="value" id="m_fragmentLoss">0h</div><small>Lost due to sub-task fragmentation</small></div>
      <div class="metric"><h3>Context Index</h3><div class="value" id="m_contextIndex">0</div><small>Higher = more scattered (1–10)</small></div>
    </div>

    <div class="chart-wrap">
      <canvas id="weekChart" width="900" height="520" aria-label="Work week calendar"></canvas>
      <div class="legend" id="legend">
        <span><i style="background:#1e88e5"></i> Focus Blocks</span>
        <span><i style="background:#ff7043"></i> Meetings</span>
        <span><i style="background:#ab47bc"></i> Recovery</span>
        <span><i style="background:#ef5350"></i> Interruptions</span>
        <span><i style="background:#26a69a"></i> Effective Output</span>
  <span><i style="background:#ffa000"></i> Lunch</span>
      </div>
      <div class="week-note" id="weekNote">Mon–Fri 08:00–16:00. Generated schedule is illustrative & heuristic.</div>
    </div>

    <p class="explain">This model is a simplified illustration. Increasing simultaneous projects raises cognitive load and reduces the average uninterrupted block size. Meetings and interruptions splinter the day, causing recovery overhead. Fragmentation penalty represents subtle productivity decay when tasks are forced into slices smaller than their natural size. Adjust sliders to see impact on effective output and switching losses.</p>

    <div class="foot-note">Assumptions: 8h gross day. Recovery applies after each meeting, interruption, and project shift. Focus block length bounded by longest focus slider and number of fragmentation events. This is not a scientific instrument — it's a conversation and intuition aid.</div>
  </div>
<script>
(function(){
  const els = id => document.getElementById(id);
  const inputs = ['projects','meetings','interrupts','focusBlock','taskSize','recovery','fragmentPenalty'].map(els);
  const OUT = {
    nominal: els('m_nominal'), focus: els('m_focus'), effective: els('m_effective'), util: els('m_util'),
    switchCost: els('m_switchCost'), fragmentLoss: els('m_fragmentLoss'), contextIndex: els('m_contextIndex')
  };
    const weekCanvas = els('weekChart');

    function calc(){
      const P = parseFloat(els('projects').value);
      const M = parseFloat(els('meetings').value);
      const I = parseFloat(els('interrupts').value);
      const F = parseFloat(els('focusBlock').value);
      const TS = parseFloat(els('taskSize').value);
      const Rm = parseFloat(els('recovery').value);
      const FragPct = parseFloat(els('fragmentPenalty').value)/100;
      const grossDayHours = 8; // includes lunch
      const lunchDur = 0.5; // fixed lunch duration excluded from capacity
      const nominalHours = grossDayHours - lunchDur;
      const meetingTime = M * 0.5;
      const interruptActive = I * (5/60);
      const switches = M + I + Math.max(0, P-1);
      const recoveryTime = switches * (Rm/60);
      const fragmentationFactor = 1 / Math.max(1, Math.pow(P, 0.55));
      const achievableFocusBlock = Math.min(F, TS, F * fragmentationFactor + 0.25);
      let rawFocus = Math.max(0, nominalHours - meetingTime - interruptActive - recoveryTime);
      const naturalBlocks = rawFocus / TS;
      const forcedBlocks = rawFocus / achievableFocusBlock;
      const extraSlices = Math.max(0, forcedBlocks - naturalBlocks);
      const fragmentLoss = extraSlices * 0.05 * achievableFocusBlock * FragPct * 2;
      const focusTime = Math.max(0, rawFocus - fragmentLoss);
      const contextScatterIndex = Math.min(10, (P * 1.6) + (M*0.35) + (I*0.18));
      const scatterPenalty = 1 - Math.min(0.55, (contextScatterIndex/10)*0.55);
      const effectiveOutput = focusTime * scatterPenalty;
      const switchCost = meetingTime + interruptActive + recoveryTime;
      OUT.nominal.textContent = nominalHours.toFixed(1)+ 'h';
      OUT.focus.textContent = focusTime.toFixed(1)+ 'h';
      OUT.effective.textContent = effectiveOutput.toFixed(1)+ 'h';
      OUT.util.textContent = Math.round((effectiveOutput/nominalHours)*100)+'%';
      OUT.switchCost.textContent = switchCost.toFixed(1)+'h';
      OUT.fragmentLoss.textContent = fragmentLoss.toFixed(1)+'h';
      OUT.contextIndex.textContent = contextScatterIndex.toFixed(1);
  // Update slider labels
  const setTxt = (id,val)=>{ const el=els(id); if(el) el.textContent=val; };
  setTxt('val_projects', P);
  setTxt('val_meetings', M);
  setTxt('val_interrupts', I);
  setTxt('val_focusBlock', F.toFixed(1)+'h');
  setTxt('val_taskSize', TS.toFixed(1)+'h');
  setTxt('val_recovery', Rm+'m');
  setTxt('val_fragmentPenalty', Math.round(FragPct*100)+'%');
      const metrics = {P,M,I,F,TS,focusTime,effectiveOutput,meetingTime,interruptActive,recoveryTime,achievableFocusBlock};
      drawWeek(metrics);
      requestAnimationFrame(()=>drawWeek(metrics));
      setTimeout(()=>drawWeek(metrics),90);
      setTimeout(()=>drawWeek(metrics),240);
    }

  function drawWeek(data){
    const dpr = window.devicePixelRatio||1;
    // Fallback width if layout not resolved yet
  let logicalWidth = weekCanvas.clientWidth;
    if(!logicalWidth || logicalWidth < 50) {
      logicalWidth = weekCanvas.parentElement ? weekCanvas.parentElement.clientWidth : 900;
      if(!logicalWidth || logicalWidth < 50) logicalWidth = 900; // final fallback
    }
  weekCanvas.width = logicalWidth * dpr;
  weekCanvas.height = 520 * dpr;
    const ctxW = weekCanvas.getContext('2d');
    ctxW.setTransform(dpr,0,0,dpr,0,0);
    ctxW.clearRect(0,0,logicalWidth,520);
    const margin = {top:30,left:60,right:30,bottom:30};
    const workHours = {start:8,end:16};
    const hourSpan = workHours.end - workHours.start; // 8
    const days = ['Mon','Tue','Wed','Thu','Fri'];
  const gridW = logicalWidth - margin.left - margin.right;
    const gridH = 460; // drawing area height
    const colW = gridW / days.length;
    const hourToY = h => margin.top + ( (h - workHours.start) / hourSpan) * gridH;
    // Background & vertical day columns
    ctxW.font = '12px system-ui';
    days.forEach((d,i)=>{
      const x = margin.left + i*colW;
      ctxW.fillStyle = i%2? '#f5f7f9' : '#f1f5f9';
      ctxW.fillRect(x, margin.top, colW, gridH);
      ctxW.fillStyle = '#24323d';
      ctxW.font = '600 13px system-ui';
      ctxW.fillText(d, x + 8, margin.top - 8);
    });
    // Hour lines
    for(let h=workHours.start; h<=workHours.end; h++){
      const y = hourToY(h);
      ctxW.strokeStyle = '#d2d9e0';
      ctxW.lineWidth = (h%1===0)?1:0.5;
      ctxW.beginPath(); ctxW.moveTo(margin.left, y); ctxW.lineTo(margin.left+gridW, y); ctxW.stroke();
      ctxW.fillStyle = '#4a5965';
      ctxW.font = '11px system-ui';
      ctxW.fillText((h<10?'0':'')+Math.floor(h)+':00', 10, y+4);
    }
  // Build per-day schedule
    const meetingDur = 0.5; // hours
    const interruptDur = 5/60; // hours
    const recoveryDur = (data.recoveryTime / Math.max(1, data.M + data.I + Math.max(0,data.P-1))) || 0; // average per event
    const usableFocus = data.focusTime; // per day
    const achievableBlock = data.achievableFocusBlock;
  const meetingSlots = [8.5,9,10,11,13,14,15];
  const palette = { focus:'#1e88e5', meeting:'#ff7043', interrupt:'#ef5350', recovery:'#ab47bc', project:'#26a69a', lunch:'#ffa000', effective:'#26a69a' };

    function scheduleDay(dayIndex){
      let events = [];
      // Lunch
      events.push({type:'lunch', start:11.5, end:12});
      // Meetings + recovery after each
      for(let m=0; m<data.M; m++) {
        const start = meetingSlots[(m+dayIndex)%meetingSlots.length];
        events.push({type:'meeting', start, end:start+meetingDur});
        events.push({type:'recovery', start:start+meetingDur, end:start+meetingDur+recoveryDur});
      }
      events.sort((a,b)=>a.start-b.start);
      // Insert focus blocks in gaps
      let pointer = workHours.start;
      let remainingFocus = usableFocus;
      const pushFocus = gapEnd => {
        while(remainingFocus>0.05 && pointer < gapEnd){
          const maxEnd = Math.min(gapEnd, pointer + Math.min(achievableBlock, remainingFocus));
          if(maxEnd - pointer < 0.05) break;
          events.push({type:'focus', start:pointer, end:maxEnd});
          remainingFocus -= (maxEnd - pointer);
          pointer = maxEnd;
          if(remainingFocus>0.05 && pointer < gapEnd){
            const recEnd = Math.min(gapEnd, pointer + recoveryDur*0.4);
            if(recEnd - pointer > 0.03){ events.push({type:'recovery', start:pointer, end:recEnd}); pointer = recEnd; }
          }
        }
      };
      events.forEach(ev=>{ if(pointer < ev.start) pushFocus(ev.start); pointer = Math.max(pointer, ev.end); });
      if(pointer < workHours.end) pushFocus(workHours.end);
      // Interruptions inserted into focus blocks
      let focusBlocks = events.filter(e=> e.type==='focus' && (e.end - e.start) > interruptDur*1.2);
      for(let k=0; k<data.I && focusBlocks.length; k++){
        const idx = (k*37 + dayIndex*13) % focusBlocks.length;
        const fb = focusBlocks[idx];
        const mid = fb.start + (fb.end - fb.start) * (0.3 + 0.4*((k+dayIndex)%3)/2);
        const intStart = Math.max(fb.start, Math.min(fb.end - interruptDur, mid - interruptDur/2));
        const intEnd = intStart + interruptDur;
        events = events.filter(e=> e!==fb);
        if(intStart - fb.start > 0.04) events.push({type:'focus', start:fb.start, end:intStart});
        events.push({type:'interrupt', start:intStart, end:intEnd});
        if(intEnd + recoveryDur < fb.end){
          events.push({type:'recovery', start:intEnd, end:Math.min(fb.end, intEnd+recoveryDur)});
          if(fb.end - (intEnd+recoveryDur) > 0.05) events.push({type:'focus', start:intEnd+recoveryDur, end:fb.end});
        } else if(fb.end - intEnd > 0.04){
          events.push({type:'focus', start:intEnd, end:fb.end});
        }
        focusBlocks = events.filter(e=> e.type==='focus' && (e.end - e.start) > interruptDur*1.2);
      }
      // Clip & sort
      events = events.filter(e=> e.start < workHours.end && e.end > workHours.start);
      events.forEach(e=> { e.start = Math.max(e.start, workHours.start); e.end = Math.min(e.end, workHours.end); });
      events.sort((a,b)=> a.start - b.start || a.type.localeCompare(b.type));
      // Fill any remaining gaps with synthetic focus so there are no blank spaces
      const filled = [];
      let cur = workHours.start;
      for(const ev of events){
        if(ev.start > cur){
          filled.push({type:'focus', start:cur, end:ev.start, synthetic:true});
        }
        filled.push(ev);
        cur = Math.max(cur, ev.end);
      }
      if(cur < workHours.end) filled.push({type:'focus', start:cur, end:workHours.end, synthetic:true});
      return filled;
    }
  // Draw events with effective overlay
    let effRemaining = data.effectiveOutput;
    days.forEach((d,di)=>{
      const dayEvents = scheduleDay(di);
      const baseX = margin.left + di*colW;
      dayEvents.forEach(ev=>{
        const x = baseX + 4;
        const y = hourToY(ev.start) + 1;
        const w = colW - 8;
        const dur = ev.end - ev.start;
        const h = Math.max(4, (dur)/hourSpan * gridH - 2);
        ctxW.fillStyle = palette[ev.type] || '#90a4ae';
        ctxW.globalAlpha = ev.type==='focus'? 0.90 : 0.85;
        ctxW.beginPath();
        ctxW.roundRect ? ctxW.roundRect(x,y,w,h,6) : ctxW.fillRect(x,y,w,h);
        ctxW.fill();
        ctxW.globalAlpha = 1;
        if(ev.type==='focus' && effRemaining > 0){
          const effChunk = Math.min(dur, effRemaining);
          const ratio = effChunk / dur;
          const effH = Math.max(3, h * ratio - 2);
          const inset = 4;
            ctxW.fillStyle = palette.effective;
            ctxW.globalAlpha = 0.85;
            const yEff = y + (h - effH)/2;
            ctxW.beginPath();
            ctxW.roundRect ? ctxW.roundRect(x+inset,yEff,w-inset*2,effH,4) : ctxW.fillRect(x+inset,yEff,w-inset*2,effH);
            ctxW.fill();
            ctxW.globalAlpha = 1;
            effRemaining -= effChunk;
        }
        ctxW.fillStyle = '#ffffff';
        ctxW.font = '600 10px system-ui';
        const label = ev.type==='focus'? 'Focus' : ev.type==='meeting'? 'Meet' : ev.type==='interrupt'? 'Int' : ev.type==='recovery'? 'Rec' : ev.type;
        if(h > 14) ctxW.fillText(label, x+6, y+12);
      });
    });
    // Title
    ctxW.fillStyle = '#1e2932';
    ctxW.font = '600 14px system-ui';
    ctxW.fillText('Weekly Calendar (Simulated)', margin.left, 18);
    if(!weekCanvas.dataset.initialized){
      weekCanvas.dataset.initialized = '1';
    }
  }

  inputs.forEach(i=> i.addEventListener('input', calc));
  window.addEventListener('resize', calc);
  calc();
})();
</script>
</body>
</html>
