<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Developer Efficiency & Context Switching</title>
<style>
 body { font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; margin:0; background:linear-gradient(135deg,#485563,#29323c); color:#1e2932; padding:18px; }
 .container { max-width:900px; margin:0 auto; background:#fff; border-radius:18px; padding:32px 34px 44px; box-shadow:0 18px 40px -12px rgba(0,0,0,.25); }
 h1 { margin:0 0 6px; font-weight:300; font-size:2.2rem; text-align:center; color:#1f2d3d; }
 .subtitle { text-align:center; color:#5f6b76; margin:0 0 26px; }
 nav a { color:#2962ff; text-decoration:none; font-weight:600; }
 nav { text-align:center; margin-bottom:24px; }
 .panel { background:#f6f8fa; border:1px solid #e2e8f0; padding:18px 20px 20px; border-radius:14px; margin-bottom:26px; }
 .panel h2 { margin:0 0 10px; font-size:1.15rem; font-weight:600; color:#253041; }
 label { font-size:.85rem; font-weight:600; display:block; margin-bottom:4px; letter-spacing:.5px; text-transform:uppercase; color:#475665; }
 input[type=range] { width:100%; }
 .grid { display:grid; gap:18px; grid-template-columns:repeat(auto-fit,minmax(190px,1fr)); margin-top:6px; }
 .metric { background:#fff; border:2px solid #e2e8f0; border-radius:12px; padding:14px 12px 16px; position:relative; }
 .metric h3 { margin:0 0 4px; font-size:.75rem; font-weight:600; letter-spacing:.6px; text-transform:uppercase; color:#5a6772; }
 .metric .value { font-size:1.9rem; font-weight:600; color:#0d47a1; line-height:1.15; }
 .metric small { display:block; font-size:.65rem; color:#607283; margin-top:2px; }
 .chart-wrap { margin-top:30px; background:#0d1117; padding:26px 22px 32px; border-radius:18px; box-shadow:0 10px 28px -8px rgba(0,0,0,.55); }
 canvas { width:100%; height:340px; display:block; background:#fff; border-radius:10px; box-shadow:0 0 0 1px #e2e8f0; }
.mode-toggle { display:flex; gap:10px; justify-content:center; margin-bottom:18px; flex-wrap:wrap; }
.mode-toggle button { background:#1e2932; color:#e2f1ff; border:1px solid #32414c; padding:8px 16px; border-radius:30px; cursor:pointer; font-size:.8rem; letter-spacing:.5px; font-weight:600; text-transform:uppercase; transition:.18s background,.18s color; }
.mode-toggle button.active { background:#2962ff; border-color:#2962ff; color:#fff; box-shadow:0 4px 14px -4px rgba(41,98,255,.55); }
.mode-toggle button:hover:not(.active){ background:#24323d; }
.week-note { text-align:center; font-size:.7rem; color:#93a2af; margin-top:10px; }
canvas#weekChart { height:760px; }
 .explain { font-size:.85rem; line-height:1.5; color:#334554; }
 .legend { display:flex; flex-wrap:wrap; gap:12px; margin-top:14px; }
 .legend span { display:inline-flex; align-items:center; gap:6px; font-size:.7rem; color:#d0d6dd; background:#1c242d; padding:6px 8px 6px 6px; border-radius:20px; }
 .legend i { width:14px; height:14px; border-radius:50%; display:inline-block; }
 .foot-note { margin-top:34px; font-size:.72rem; color:#637383; line-height:1.4; }
 .dual { display:flex; gap:26px; flex-wrap:wrap; }
 .dual > div { flex:1 1 260px; }
 .inline { display:flex; gap:12px; flex-wrap:wrap; }
 .inline .w50 { flex:1 1 120px; min-width:120px; }
 .slval { color:#0d47a1; background:#e3f2fd; padding:2px 6px; border-radius:10px; font-size:.65rem; margin-left:4px; }
 .chart-wrap { position:relative; }
 .cal-tip { position:absolute; pointer-events:none; background:rgba(20,24,28,.95); color:#e7eef5; font-size:.65rem; padding:6px 8px 6px; border-radius:6px; line-height:1.3; box-shadow:0 4px 14px -4px rgba(0,0,0,.5); transform:translate(-50%,-8px); z-index:10; opacity:0; transition:opacity .12s; white-space:nowrap; font-weight:500; border:1px solid #2d3944; }
 .cal-tip.visible { opacity:1; }
</style>
</head>
<body>
  <div class="container">
    <nav><a href="index.html">← Back to Network Complexity</a></nav>
    <h1>Developer Context Switching Efficiency</h1>
    <p class="subtitle">How meetings, project fragmentation, and interruptions erode effective output</p>

    <div class="panel">
      <h2>Interactive Factors</h2>
      <div class="dual">
        <div>
          <label for="projects">Concurrent Projects <span class="slval" id="val_projects">3</span></label>
          <input id="projects" type="range" min="1" max="8" value="3" />
        </div>
        <div>
          <label for="meetings">Meetings / Week <span class="slval" id="val_meetings">2</span></label>
          <input id="meetings" type="range" min="0" max="28" value="2" />
        </div>
        <div>
          <label for="interrupts">Unplanned Interruptions <span class="slval" id="val_interrupts">5</span></label>
          <input id="interrupts" type="range" min="0" max="16" value="5" />
        </div>
        <div>
          <label for="focusBlock">Longest Focus Block (hrs) <span class="slval" id="val_focusBlock">2.0h</span></label>
          <input id="focusBlock" type="range" min="0.5" max="4" step="0.5" value="2" />
        </div>
      </div>
      <div class="inline" style="margin-top:14px;">
        <div class="w50">
          <label for="taskSize">Avg Task Size (hrs) <span class="slval" id="val_taskSize">2.0h</span></label>
          <input id="taskSize" type="range" min="0.5" max="8" step="0.5" value="2" />
        </div>
        <div class="w50">
          <label for="recovery">Context Recovery (min) <span class="slval" id="val_recovery">12m</span></label>
          <input id="recovery" type="range" min="2" max="45" step="1" value="12" />
        </div>
        <div class="w50">
          <label for="fragmentPenalty">Fragmentation Penalty % <span class="slval" id="val_fragmentPenalty">18%</span></label>
          <input id="fragmentPenalty" type="range" min="0" max="40" step="1" value="18" />
        </div>
      </div>
    </div>

    <div class="grid" id="metrics">
      <div class="metric"><h3>Nominal Capacity</h3><div class="value" id="m_nominal">0h</div><small>Hours theoretically available (8h baseline)</small></div>
      <div class="metric"><h3>Focus Time</h3><div class="value" id="m_focus">0h</div><small>Estimated deep work hours</small></div>
      <div class="metric"><h3>Effective Output</h3><div class="value" id="m_effective">0h</div><small>Focus time after switching drag</small></div>
      <div class="metric"><h3>Utilization</h3><div class="value" id="m_util">0%</div><small>Effective / Nominal</small></div>
      <div class="metric"><h3>Switch Cost</h3><div class="value" id="m_switchCost">0h</div><small>Time lost to project/meeting/task switching</small></div>
      <div class="metric"><h3>Fragment Loss</h3><div class="value" id="m_fragmentLoss">0h</div><small>Lost due to sub-task fragmentation</small></div>
      <div class="metric"><h3>Context Index</h3><div class="value" id="m_contextIndex">0</div><small>Higher = more scattered (1–10)</small></div>
    </div>

    <div class="chart-wrap">
  <canvas id="weekChart" width="900" height="760" aria-label="Work week calendar"></canvas>
  <div id="calTooltip" class="cal-tip"></div>
      <div class="legend" id="legend">
        <span><i style="background:#1e88e5"></i> Focus Blocks</span>
        <span><i style="background:#ff7043"></i> Meetings</span>
        <span><i style="background:#ab47bc"></i> Recovery</span>
        <span><i style="background:#ef5350"></i> Interruptions</span>
        <span><i style="background:#26a69a"></i> Effective Output</span>
  <span><i style="background:#ffa000"></i> Lunch</span>
  <span><i style="background:#ffd54f"></i> Socializing</span>
      </div>
      <div class="week-note" id="weekNote">Mon–Fri 08:00–16:00. Generated schedule is illustrative & heuristic.</div>
    </div>

    <p class="explain">This model is a simplified illustration. Increasing simultaneous projects raises cognitive load and reduces the average uninterrupted block size. Meetings and interruptions splinter the day, causing recovery overhead. Fragmentation penalty represents subtle productivity decay when tasks are forced into slices smaller than their natural size. Adjust sliders to see impact on effective output and switching losses.</p>

    <div class="foot-note">Assumptions: 8h gross day. Recovery applies after each meeting, interruption, and project shift. Focus block length bounded by longest focus slider and number of fragmentation events. This is not a scientific instrument — it's a conversation and intuition aid.</div>
  </div>
<script>
(function(){
  const els = id => document.getElementById(id);
  const inputs = ['projects','meetings','interrupts','focusBlock','taskSize','recovery','fragmentPenalty'].map(els);
  const OUT = {
    nominal: els('m_nominal'), focus: els('m_focus'), effective: els('m_effective'), util: els('m_util'),
    switchCost: els('m_switchCost'), fragmentLoss: els('m_fragmentLoss'), contextIndex: els('m_contextIndex')
  };
    const weekCanvas = els('weekChart');
  // Cached randomized weekly meeting distribution
  let meetingMapCache = null; // {0:[],1:[],2:[],3:[],4:[]}
  let prevMeetingCount = null;
  function generateMeetingMap(totalMeetings){
    const slots = [9.5,10,10.5,11,13,13.5,14,14.5]; // allowed start times
    const days = [0,1,2,3]; // Mon-Thu only
    const candidates = [];
    days.forEach(d=> slots.forEach(s=> candidates.push({day:d,start:s})));
    // Fisher-Yates shuffle for randomness
    for(let i=candidates.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [candidates[i],candidates[j]] = [candidates[j],candidates[i]];
    }
    const picked = candidates.slice(0, totalMeetings);
    const map = {0:[],1:[],2:[],3:[],4:[]};
    picked.forEach(p=> map[p.day].push(p.start));
    Object.values(map).forEach(arr=> arr.sort((a,b)=>a-b));
    return map;
  }

  const eventRects = []; // reused per render
  function calc(){
      const P = parseFloat(els('projects').value);
  const MWeek = parseFloat(els('meetings').value); // weekly meetings
      const I = parseFloat(els('interrupts').value);
      const F = parseFloat(els('focusBlock').value);
      const TS = parseFloat(els('taskSize').value);
      const Rm = parseFloat(els('recovery').value);
      const FragPct = parseFloat(els('fragmentPenalty').value)/100;
      const grossDayHours = 8; // includes lunch
      const lunchDur = 0.5; // fixed lunch duration excluded from capacity
  const socialDur = 0.25; // 15 min post-lunch socializing
  const nominalHours = grossDayHours - lunchDur - socialDur; // remove lunch & socializing from productive capacity
  const meetingsPerDayAvg = MWeek / 5;
  const meetingTime = meetingsPerDayAvg * 0.5; // each meeting 0.5h, averaged per day
      const interruptActive = I * (5/60);
  // Regenerate random meeting map only when meeting count changes
  if(prevMeetingCount !== MWeek){
    meetingMapCache = generateMeetingMap(MWeek);
    prevMeetingCount = MWeek;
  }
  // Compute recovery events tied to meetings based on actual randomized distribution
  const meetingDur = 0.5;
  const LUNCH_START = 11.5, LUNCH_END = 12;
  let adjPairs = 0, lunchSupp = 0;
  for(const d of [0,1,2,3]){
    const starts = meetingMapCache ? meetingMapCache[d] : [];
    for(let i=0;i<starts.length;i++){
      const start = starts[i];
      const end = start + meetingDur;
      if(i<starts.length-1 && Math.abs(starts[i+1]-start-meetingDur)<1e-6) adjPairs++;
      if(Math.abs(end-LUNCH_START)<1e-6 || (end> LUNCH_START && end < LUNCH_END) || Math.abs(end-LUNCH_END)<1e-6) lunchSupp++;
    }
  }
  let effectiveMeetingRecoveriesWeek = MWeek - adjPairs - lunchSupp;
  if(effectiveMeetingRecoveriesWeek < 0) effectiveMeetingRecoveriesWeek = 0;
  const meetingRecoveriesPerDayAvg = effectiveMeetingRecoveriesWeek / 5;
  // Add interruptions + project shift recoveries per day
  const recoveryEventsDaily = meetingRecoveriesPerDayAvg + I + Math.max(0, P-1);
  const perEventRecovery = Rm/60;
  const recoveryTime = recoveryEventsDaily * perEventRecovery;
      const fragmentationFactor = 1 / Math.max(1, Math.pow(P, 0.55));
      const achievableFocusBlock = Math.min(F, TS, F * fragmentationFactor + 0.25);
      let rawFocus = Math.max(0, nominalHours - meetingTime - interruptActive - recoveryTime);
      const naturalBlocks = rawFocus / TS;
      const forcedBlocks = rawFocus / achievableFocusBlock;
      const extraSlices = Math.max(0, forcedBlocks - naturalBlocks);
      const fragmentLoss = extraSlices * 0.05 * achievableFocusBlock * FragPct * 2;
      const focusTime = Math.max(0, rawFocus - fragmentLoss);
  const contextScatterIndex = Math.min(10, (P * 1.6) + (meetingsPerDayAvg*0.35) + (I*0.18));
      const scatterPenalty = 1 - Math.min(0.55, (contextScatterIndex/10)*0.55);
      const effectiveOutput = focusTime * scatterPenalty;
      const switchCost = meetingTime + interruptActive + recoveryTime;
      OUT.nominal.textContent = nominalHours.toFixed(1)+ 'h';
      OUT.focus.textContent = focusTime.toFixed(1)+ 'h';
      OUT.effective.textContent = effectiveOutput.toFixed(1)+ 'h';
      OUT.util.textContent = Math.round((effectiveOutput/nominalHours)*100)+'%';
      OUT.switchCost.textContent = switchCost.toFixed(1)+'h';
      OUT.fragmentLoss.textContent = fragmentLoss.toFixed(1)+'h';
      OUT.contextIndex.textContent = contextScatterIndex.toFixed(1);
  // Update slider labels
  const setTxt = (id,val)=>{ const el=els(id); if(el) el.textContent=val; };
  setTxt('val_projects', P);
  setTxt('val_meetings', MWeek);
  setTxt('val_interrupts', I);
  setTxt('val_focusBlock', F.toFixed(1)+'h');
  setTxt('val_taskSize', TS.toFixed(1)+'h');
  setTxt('val_recovery', Rm+'m');
  setTxt('val_fragmentPenalty', Math.round(FragPct*100)+'%');
  const metrics = {P,MWeek,I,F,TS,focusTime,effectiveOutput,meetingTime,interruptActive,recoveryTime,achievableFocusBlock, meetingsPerDayAvg, meetingMap: meetingMapCache, perEventRecovery};
      drawWeek(metrics);
      requestAnimationFrame(()=>drawWeek(metrics));
      setTimeout(()=>drawWeek(metrics),90);
      setTimeout(()=>drawWeek(metrics),240);
    }

  function drawWeek(data){
    eventRects.length = 0;
    const dpr = window.devicePixelRatio||1;
    // Fallback width if layout not resolved yet
  let logicalWidth = weekCanvas.clientWidth;
    if(!logicalWidth || logicalWidth < 50) {
      logicalWidth = weekCanvas.parentElement ? weekCanvas.parentElement.clientWidth : 900;
      if(!logicalWidth || logicalWidth < 50) logicalWidth = 900; // final fallback
    }
  const TOTAL_HEIGHT = 760;
  weekCanvas.width = logicalWidth * dpr;
  weekCanvas.height = TOTAL_HEIGHT * dpr;
    const ctxW = weekCanvas.getContext('2d');
    ctxW.setTransform(dpr,0,0,dpr,0,0);
  ctxW.clearRect(0,0,logicalWidth,TOTAL_HEIGHT);
  const margin = {top:30,left:60,right:30,bottom:30};
    const workHours = {start:8,end:16};
    const hourSpan = workHours.end - workHours.start; // 8
    const days = ['Mon','Tue','Wed','Thu','Fri'];
  const gridW = logicalWidth - margin.left - margin.right;
    const gridH = TOTAL_HEIGHT - (margin.top + margin.bottom); // dynamic drawing area height
    const colW = gridW / days.length;
    const hourToY = h => margin.top + ( (h - workHours.start) / hourSpan) * gridH;
    // Background & vertical day columns
    ctxW.font = '12px system-ui';
    days.forEach((d,i)=>{
      const x = margin.left + i*colW;
      ctxW.fillStyle = i%2? '#f5f7f9' : '#f1f5f9';
      ctxW.fillRect(x, margin.top, colW, gridH);
      ctxW.fillStyle = '#24323d';
      ctxW.font = '600 13px system-ui';
      ctxW.fillText(d, x + 8, margin.top - 8);
    });
    // Hour lines
    for(let h=workHours.start; h<=workHours.end; h++){
      const y = hourToY(h);
      ctxW.strokeStyle = '#d2d9e0';
      ctxW.lineWidth = (h%1===0)?1:0.5;
      ctxW.beginPath(); ctxW.moveTo(margin.left, y); ctxW.lineTo(margin.left+gridW, y); ctxW.stroke();
      ctxW.fillStyle = '#4a5965';
      ctxW.font = '11px system-ui';
      ctxW.fillText((h<10?'0':'')+Math.floor(h)+':00', 10, y+4);
    }
  // Build per-day schedule
  const meetingDur = 0.5; // hours
  const interruptDur = 5/60; // hours
  const recoveryDur = data.perEventRecovery || 0; // per-event recovery duration
  const usableFocus = data.focusTime; // per day
    const achievableBlock = data.achievableFocusBlock;
  const meetingSlots = [9.5,10,10.5,11,13,13.5,14,14.5];
  const palette = { focus:'#1e88e5', meeting:'#ff7043', interrupt:'#ef5350', recovery:'#ab47bc', project:'#26a69a', lunch:'#ffa000', social:'#ffd54f', effective:'#26a69a' };

    function scheduleDay(dayIndex){
      let events = [];
  // Lunch and socializing block
  events.push({type:'lunch', start:11.5, end:12});
  events.push({type:'social', start:12, end:12.25});
      // Meetings distributed Mon-Thu only, none on Fri
      if(data.MWeek>0 && dayIndex < 4){
        const mtStartsDay = (data.meetingMap && data.meetingMap[dayIndex]) ? data.meetingMap[dayIndex] : [];
        for(let i=0;i<mtStartsDay.length;i++){
          const start = mtStartsDay[i];
          const end = start + meetingDur;
          events.push({type:'meeting', start, end});
          const nextStart = mtStartsDay[i+1];
          const backToBack = (typeof nextStart==='number') && Math.abs(nextStart - start - meetingDur) < 1e-6;
          const lunchOverlap = (Math.abs(end - 11.5) < 1e-6) || (end > 11.5 && end < 12) || (Math.abs(end - 12) < 1e-6);
            if(!backToBack && !lunchOverlap){
              events.push({type:'recovery', start:end, end:end+recoveryDur});
            }
        }
      }
      events.sort((a,b)=>a.start-b.start);
      // Insert focus blocks in gaps
      let pointer = workHours.start;
      let remainingFocus = usableFocus;
      const pushFocus = gapEnd => {
        while(remainingFocus>0.05 && pointer < gapEnd){
          const maxEnd = Math.min(gapEnd, pointer + Math.min(achievableBlock, remainingFocus));
          if(maxEnd - pointer < 0.05) break;
          events.push({type:'focus', start:pointer, end:maxEnd});
          remainingFocus -= (maxEnd - pointer);
          pointer = maxEnd;
          if(remainingFocus>0.05 && pointer < gapEnd){
            const recEnd = Math.min(gapEnd, pointer + recoveryDur*0.4);
            if(recEnd - pointer > 0.03){ events.push({type:'recovery', start:pointer, end:recEnd}); pointer = recEnd; }
          }
        }
      };
      events.forEach(ev=>{ if(pointer < ev.start) pushFocus(ev.start); pointer = Math.max(pointer, ev.end); });
      if(pointer < workHours.end) pushFocus(workHours.end);
      // Interruptions inserted into focus blocks
      let focusBlocks = events.filter(e=> e.type==='focus' && (e.end - e.start) > interruptDur*1.2);
      for(let k=0; k<data.I && focusBlocks.length; k++){
        const idx = (k*37 + dayIndex*13) % focusBlocks.length;
        const fb = focusBlocks[idx];
        const mid = fb.start + (fb.end - fb.start) * (0.3 + 0.4*((k+dayIndex)%3)/2);
        const intStart = Math.max(fb.start, Math.min(fb.end - interruptDur, mid - interruptDur/2));
        const intEnd = intStart + interruptDur;
        events = events.filter(e=> e!==fb);
        if(intStart - fb.start > 0.04) events.push({type:'focus', start:fb.start, end:intStart});
        events.push({type:'interrupt', start:intStart, end:intEnd});
        if(intEnd + recoveryDur < fb.end){
          events.push({type:'recovery', start:intEnd, end:Math.min(fb.end, intEnd+recoveryDur)});
          if(fb.end - (intEnd+recoveryDur) > 0.05) events.push({type:'focus', start:intEnd+recoveryDur, end:fb.end});
        } else if(fb.end - intEnd > 0.04){
          events.push({type:'focus', start:intEnd, end:fb.end});
        }
        focusBlocks = events.filter(e=> e.type==='focus' && (e.end - e.start) > interruptDur*1.2);
      }
      // Clip & sort
      events = events.filter(e=> e.start < workHours.end && e.end > workHours.start);
      events.forEach(e=> { e.start = Math.max(e.start, workHours.start); e.end = Math.min(e.end, workHours.end); });
      events.sort((a,b)=> a.start - b.start || a.type.localeCompare(b.type));
      // Fill any remaining gaps with synthetic focus so there are no blank spaces
      const filled = [];
      let cur = workHours.start;
      for(const ev of events){
        if(ev.start > cur){
          filled.push({type:'focus', start:cur, end:ev.start, synthetic:true});
        }
        filled.push(ev);
        cur = Math.max(cur, ev.end);
      }
      if(cur < workHours.end) filled.push({type:'focus', start:cur, end:workHours.end, synthetic:true});
      return filled;
    }
  // Draw events with effective overlay
  let effRemaining = data.effectiveOutput;
    days.forEach((d,di)=>{
      const dayEvents = scheduleDay(di);
      const baseX = margin.left + di*colW;
      dayEvents.forEach(ev=>{
        const x = baseX + 4;
        const y = hourToY(ev.start) + 1;
        const w = colW - 8;
        const dur = ev.end - ev.start;
        const h = Math.max(4, (dur)/hourSpan * gridH - 2);
    eventRects.push({x,y,w,h,type:ev.type,start:ev.start,end:ev.end});
        ctxW.fillStyle = palette[ev.type] || '#90a4ae';
        ctxW.globalAlpha = ev.type==='focus'? 0.90 : 0.85;
        ctxW.beginPath();
        ctxW.roundRect ? ctxW.roundRect(x,y,w,h,6) : ctxW.fillRect(x,y,w,h);
        ctxW.fill();
        ctxW.globalAlpha = 1;
        if(ev.type==='focus' && effRemaining > 0){
          const effChunk = Math.min(dur, effRemaining);
          const ratio = effChunk / dur;
          const effH = Math.max(3, h * ratio - 2);
          const inset = 4;
            ctxW.fillStyle = palette.effective;
            ctxW.globalAlpha = 0.85;
            const yEff = y + (h - effH)/2;
            ctxW.beginPath();
            ctxW.roundRect ? ctxW.roundRect(x+inset,yEff,w-inset*2,effH,4) : ctxW.fillRect(x+inset,yEff,w-inset*2,effH);
            ctxW.fill();
            ctxW.globalAlpha = 1;
            effRemaining -= effChunk;
        }
        ctxW.fillStyle = '#ffffff';
        ctxW.font = '600 10px system-ui';
        const label = ev.type==='focus'? 'Focus' : ev.type==='meeting'? 'Meet' : ev.type==='interrupt'? 'Int' : ev.type==='recovery'? 'Rec' : ev.type;
        if(h > 14) ctxW.fillText(label, x+6, y+12);
      });
    });
    // Title
    ctxW.fillStyle = '#1e2932';
    ctxW.font = '600 14px system-ui';
    ctxW.fillText('Weekly Calendar (Simulated)', margin.left, 18);
    if(!weekCanvas.dataset.initialized){
      weekCanvas.dataset.initialized = '1';
    }
  }

  // Hover tooltip
  const tip = document.getElementById('calTooltip');
  function fmtTime(t){
    const hh = Math.floor(t);
    const mm = Math.round((t - hh)*60);
    return (hh<10?'0':'')+hh+':'+(mm<10?'0':'')+mm;
  }
  weekCanvas.addEventListener('mousemove', e=>{
    const rect = weekCanvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio||1;
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const hit = eventRects.find(r=> x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h);
    if(hit){
  const labelMap = {focus:'Focus', meeting:'Meeting', interrupt:'Interruption', recovery:'Recovery', lunch:'Lunch', social:'Socializing'};
      tip.innerHTML = labelMap[hit.type]||hit.type;
      tip.innerHTML += '<br>'+fmtTime(hit.start)+'–'+fmtTime(hit.end);
      tip.style.left = x+'px';
      tip.style.top = y+'px';
      tip.classList.add('visible');
    } else {
      tip.classList.remove('visible');
    }
  });
  weekCanvas.addEventListener('mouseleave',()=> tip.classList.remove('visible'));

  inputs.forEach(i=> i.addEventListener('input', calc));
  window.addEventListener('resize', calc);
  calc();
})();
</script>
</body>
</html>
